---
title: "R Practice"
author: "Meredith Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Cervical Cancer Risk Factors

## Introduction

This is an example notebook in which we explore a dataset of cervical cancer risk factors from the [University of California Irvine Machine Learning Database](https://archive.ics.uci.edu/ml/index.php). Note that the "solution" below is not the only way to approach this task! 

Also keep in mind that this is an edited final product. The process of creating a notebook like this, however, can look quite a bit different! Remember that notebooks like this are places for you to try things out (even if they don't work the first time), make notes, and really just play with the data. Don't worry about polish at this stage-- this is practice!

### Import packages

The first thing we'll want to do is to import any libraries/packages that we'll need. You might have to install some or all of these packages using `install.packages()`.

```{r import-packages}
library(tidyverse)
library(janitor)
library(GGally)
```

Next we need to import our data. We can do this by reading in the CSV using the `read_csv()` function in `readr` (part of the `tidyverse`).  

```{r import-dataset}
raw_data <- read_csv("http://archive.ics.uci.edu/ml/machine-learning-databases/00383/risk_factors_cervical_cancer.csv")
```

Then, we can take a peek at data by using the Environment tab and clicking or by using `View()`. 

```{r eval = FALSE}
View(raw_data)
```

Looking through the data, there seem to be a lot of question marks! This is likely indicting missing data. R is not going to be able to handle question marks every well, and it will definitely mess up our math later! Let's re-import the data, letting R know that the question marks should be coded as `NA` (a special value in R that means "empty" or "null").

```{r import-data-with-NA}
cervical_cancer_data <- read_csv("http://archive.ics.uci.edu/ml/machine-learning-databases/00383/risk_factors_cervical_cancer.csv", na = c("?", "NA"))
```

## Data exploration

Next, let's dig into the data itself. First, let's look at a statistical summary table.

```{r}
summary(cervical_cancer_data)
```

One thing to notice here is that there are spaces, capital letters, and colons in our column names. This (especially the spaces) will likely cause problems later when we want to work with the data. Let's change everything to lowercase and replace the spaces and colons with underscores (this is called "snakecase"). There are a few ways to do this: 

1. We could create a vector with all of the new valid column names and replace the old ones. That's a lot of typing on our part though, which leaves lots of places for errors to be introduced! 
2. We could use the functions `tolower()` to make everything lower case and then use the `str_replace_all()` from the `stringr` library to replace spaces and colons with underscores. This only requires two lines of code-- not bad! 
3. We could use the `clean_names()` function from the `janitor` library, which will change everything to snakecase in one step.

```{r}
cervical_cancer_data <- clean_names(cervical_cancer_data, parsing_option=3)
colnames(cervical_cancer_data)
```

### Recoding Logical Variables

If we look closely, we can see that there are a few columns that are likely True/False (or "logical") variables (like `Smokes` for example) that are being treated like numerical variables. We should look in the data dictionary of the dataset (found here: https://archive.ics.uci.edu/ml/datasets/Cervical+cancer+%28Risk+Factors%29). It's sparse, but we can find out which columns are supposed to be True/False and change those column types. Usually, when data are coded this way, 1 means "True" and 0 means "False". 
Let's list all of the logical variables and then change their data type using `mutate()`, `across()` and `as.logical()`.

For more information about using `mutate()` and `across()`, see the examples using `across()` here (scroll down to the examples section): https://dplyr.tidyverse.org/reference/mutate_all.html

```{r change-variable-types}
logical_cols <- c("smokes", "hormonal_contraceptives", "iud", "stds", 
                  "stds_condylomatosis", "stds_cervical_condylomatosis", 
                  "stds_vaginal_condylomatosis", 
                  "stds_vulvo_perineal_condylomatosis", 
                  "stds_syphilis", "stds_pelvic_inflammatory_disease", 
                  "stds_genital_herpes", "stds_molluscum_contagiosum", 
                  "stds_aids", "stds_hiv", "stds_hepatitis_b", "stds_hpv",
                  "dx_cancer", "dx_cin", "dx_hpv", "dx", "hinselmann",
                  "schiller", "citology", "biopsy")

cervical_cancer_data <- mutate(cervical_cancer_data, across(all_of(logical_cols), as.logical))
```

Now that we've done that, let's look at a statistical summary of just the entries where the `dx_cancer` is True. 

```{r}
cancer_pos <- cervical_cancer_data %>% 
  filter(dx_cancer == TRUE) %>% 
  summary()
cancer_pos
```

## Exploratory data visualization 

Now, let's do some data visualization to explore the data. We may be able to find patterns that aren't easily seen by looking at numbers alone. 

### Histograms

First, let's look at some histograms using `ggplot`.


```{r}
ggplot(data = cervical_cancer_data) +
  geom_histogram(mapping = aes(x = age))
```

```{r}
ggplot(data = cervical_cancer_data) +
  geom_histogram(mapping = aes(x = smokes_years), binwidth = 1)
```

**What if you want to see a histogram for every numeric variable in the data?**

We can do that by taking advantage of `pivot_longer` (from the `tidyr` package) and `facet_wrap` (from `ggplot2` package). First, `pivot_longer` transforms the data from wide to long format for all of the numeric columns. This creates a new column called "name" with all of the variable names from the numeric variables, and a column called "value" with the data from those columns. 
Then, we send that long dataframe to `ggplot` and create a histogram of everything in the `value` column -- this will be all of the values for all of the numeric variables in the data, so one big histogram of all of that wouldn't make any sense. But we can use `facet_wrap` to split the histogram out for each level in the `name` column, i.e. for each variable. 

```{r}
# first, take a look at what the data look like after transforming to long, just to see the new shape
cervical_cancer_data %>% 
  pivot_longer(cols = where(is.numeric), names_to = "name", values_to = "value") %>%
  View()

# transform the data to long, then create a histogram and use facet_wrap to break it up by variable
cervical_cancer_data %>% 
  pivot_longer(cols = where(is.numeric), names_to = "name", values_to = "value") %>%
  ggplot() +
  geom_histogram(mapping = aes(x=value)) + 
  facet_wrap(~ name, scales = "free")
```

### Scatterplots

How about some scatterplots? 

```{r}
ggplot(data = cervical_cancer_data) +
  geom_point(mapping = aes(x = number_of_sexual_partners, y = stds_number))
```

```{r}
ggplot(data = cervical_cancer_data) +
  geom_point(mapping = aes(x = age, y = stds_number))
```

Wondering how to get scatterplots for every pair of numeric variables? That's a little trickier than histograms since you need to work with pairs of variables instead of single variables. But luckily there are some ready functions designed to do exactly that!

Option 1: Use the `pairs` function (which is in base R, not the `ggplot2` package we've used for most of our plotting so far). 

```{r}
cervical_cancer_data %>%
  select(where(is.numeric)) %>%
  pairs()
```

Option 2: Use the `ggpairs` function from the `GGally` package, which is a package with a bunch of functions designed to extend `ggplot2`.

```{r}
cervical_cancer_data %>%
  select(where(is.numeric)) %>%
  ggpairs()
```

### Boxplots

Let's look at a box plot next.

```{r}
ggplot(data = cervical_cancer_data) +
  geom_boxplot(mapping = aes(y = number_of_sexual_partners))
```

If you like, you can generate a boxplot for every numeric variable, like we did for the histograms. Give it a try!

### Heat Maps and correlations

Now, let's take a look at the correlations between all of the variables. We can do this by creating a correlation matrix with the `cor` function. Note that correlations should only be computed on numeric variables, so we'll select for just our numeric variables first.

```{r}
corr_matrix <- cor(select(cervical_cancer_data, where(is.numeric)), use="pairwise.complete.obs")

round(corr_matrix, 2) # round to two decimal places to make the numbers easier to read
```

It can be hard to visually scan numbers, though. 
We can represent the correlation matrix as a heatmap using `ggcorr` from the `GGally` package. 

```{r}
cervical_cancer_data %>%
  select(where(is.numeric)) %>%
  ggcorr() 

# try adding the argument label=TRUE to the ggcorr() command!
```

Note that ggcorr defaults to Pearson correlations, and use="pairwise.complete.obs".
You can change both the type of correlation and the way of handling missing data with the `method` argument in `ggcorr`, see the help documentation (run `?ggcorr` in the console) for details. 


## What variables might be related to cancer diagnosis?

First, let's consider our numeric variables. 
To get an idea of which numeric variables are different for patients with a cancer diagnosis vs. without (TRUE vs. FALSE in the `dx_cancer` variable), let's generate boxplots for all of the variables and separate out on `dx_cancer` by color. 

```{r}
cervical_cancer_data %>% 
  pivot_longer(cols = where(is.numeric), names_to = "name", values_to = "value") %>%
  ggplot() +
  geom_boxplot(mapping = aes(y=value, fill=dx_cancer)) + 
  facet_wrap(~ name, scales = "free")
```

Do you notice any interesting patterns?

Now let's take a look at the other variables in the data, the logical variables. 

```{r}
cervical_cancer_data %>% 
  select(where(is.logical)) %>%
  pivot_longer(cols = -dx_cancer, names_to = "name", values_to = "value") %>%
  ggplot() +
  geom_bar(mapping = aes(x=value, fill=dx_cancer), position = "dodge") + 
  facet_wrap(~ name, scales = "free_y")
```

Because there are so many more cases without a cancer diagnosis than with, it's hard to see the patterns in the cases where dx_cancer = TRUE. 
Let's try plotting them separately, using dx_cancer as a second variable in `facet_wrap`. 
This will create a new plot for each of the logical variables for each level of dx_cancer (so one plot of the biopsy variable for dx_cancer=TRUE, and another plot of the biopsy variable for dx_cancer=FALSE, etc.)

(Another way to compare categorical variables (like the logical variables we're examining here) is with mosaic plots. 
To learn more, check out the [ggmosaic package](https://haleyjeppson.github.io/ggmosaic/).)

```{r}
cervical_cancer_data %>% 
  select(where(is.logical)) %>%
  pivot_longer(cols = -dx_cancer, names_to = "name", values_to = "value") %>%
  ggplot() +
  geom_bar(mapping = aes(x=value, fill=dx_cancer), position = "dodge") + 
  facet_wrap(~ name + dx_cancer, scales = "free_y")
```

And here's another option for plotting the same data. There are many, many possible ways to visualize this!

```{r}
cervical_cancer_data %>% 
  select(where(is.logical)) %>%
  pivot_longer(cols = -dx_cancer, names_to = "name", values_to = "value") %>%
  ggplot() +
  geom_bar(mapping = aes(x=dx_cancer, fill = value), position = "fill") + 
  facet_wrap( ~ name , scales = "fixed")
```

Do you notice any variables that have quite different distributions depending on whether we look at cases where dx_cancer=TRUE vs. dx_cancer=FALSE?
